\begin{summary}
    \begin{itemize}
        \item The kernel is the part of the operating system (OS) that interacts with hardware (it runs in kernel mode).
        \item System calls are the interface between user and kernel mode:
        \begin{itemize}
            \item Every program must use this interface!
        \end{itemize}
        \item File format and instructions to define a simple “Hello world” (in 168 bytes):
        \begin{itemize}
            \item Difference between API and ABI.
            \item How to explore system calls.
        \end{itemize}
        \item Different kernel architectures shift how much code runs in kernel mode.
    \end{itemize}    
\end{summary}

\begin{faq}
    \begin{itemize}
        \item What is difference b/w printf and write?
    \end{itemize}
\end{faq}
\subsection{File Descriptor (Abstraction)}
\begin{motivation}
    Since our processes are independent, we need an explicit way to transfer data.
\end{motivation}

\begin{definition}
    \begin{enumerate}
        \item \textbf{IPC:} Inter-process communication is transferring data b/w two processes.
        \item \textbf{File Descriptor:} A resource that users may either read bytes from or write bytes to (identified by an index stored in a process).
        \begin{itemize}
            \item e.g. File or terminal.
            \item e.g. 0 is standard input, 1 is standard output, and 2 is standard error.
        \end{itemize}
    \end{enumerate}
\end{definition}

\subsection{System Calls}
\begin{definition}
    System calls are the interface b/w user and kernel mode.
\end{definition}

\subsubsection{System Calls Make Requests to the Operating System}
\begin{definition}
\begin{lstlisting}[language=C]
ssize_t write(int fd, const void *buf, size_t count);
\end{lstlisting}
\begin{itemize}
    \item Description: writes bytes from a byte array to a file descriptor
    \begin{itemize}
        \item fd: the file descriptor
        \item buf: the address of the start of the byte array (called a buffer)
        \item count: how many bytes to write from the buffer
    \end{itemize}
\end{itemize}

\begin{lstlisting}[language=C]
void exit_group(int status);
\end{lstlisting}

\begin{itemize}
    \item Description: exits the current process and sets an exit status code
    \begin{itemize}
        \item status: the exit status code (0–255)
    \end{itemize}
\end{itemize}  
\end{definition}

\begin{example}
    \textbf{Hypothetical "Hello World" Program}
\begin{lstlisting}[language=C]
void _start(void) {
    write(1, "Hello world\n", 12);
    exit_group(0);
}
\end{lstlisting}
\end{example}

\begin{warning}
    System calls uses registers, while C is stack based.
\end{warning}

\subsection{API Tells You What and ABI Tells You How}
\begin{definition}
    \begin{itemize}
        \item Application Programming Interface (API) abstracts the details and describes the arguments and return value of a function.
        \item Application Binary Interface (ABI) specifies the details, specifically how to pass arguments and where the return value is.
    \end{itemize}
\end{definition}

\subsection{Magic}
\begin{definition}
    The "magic bytes" refer to the first 4 bytes of a file that uniquely identify the file format. 
\end{definition}

\subsubsection{Programs on Linux Use the ELF File Format}
\begin{definition}
    Executable and Linkable Format (ELF) specifies both executables and libraries.
    \begin{itemize}
        \item Always starts with the 4 bytes: 0x7F 0x45 0x4C 0x46 or with ASCII encoding: DEL 'E' 'L' 'F'
    \end{itemize}
\end{definition}

\begin{example} \textbf{Hello World ELF File}
    \begin{enumerate}
        \item \textbf{168 Byte Program:}
        \begin{itemize}
            \item Tells the OS to load the entire executable file into memory at address \texttt{0x10000}.
            \item The file header is 64 bytes, and the ``program header'' is 56 bytes (120 bytes total).
            \item The next 36 bytes are instructions, followed by 12 bytes for the string:
                \begin{itemize}
                    \item \texttt{"Hello world\textbackslash n"}
                    \item Instructions start at \texttt{0x10078} (\texttt{0x78} is 120).
                    \item The string (data) starts at \texttt{0x1009C} (\texttt{0x9C} is 156).
                \end{itemize}
        \end{itemize} 
        \customFigure[0.5]{Images/L1_1.png}{ELF File Division}
        \item \textbf{C Program:} Takes 500 bytes.
        \item \textbf{Python Program:} Takes 2000 bytes.
        \item \textbf{Java Program:} Takes 2000000 bytes.
    \end{enumerate}
\end{example}

\subsection{Kernel}
\begin{definition}
    Kernel is a core part of the operating system that interacts with hardware that runs in kernel mode. 
\end{definition}

\subsubsection{Kernel Mode}
\begin{definition}
    Kernel mode is a privilege level on your CPU that gives access to more instructions.
\end{definition}

\subsubsection{Levels of Privelege}
\begin{definition}
    \customFigure[0.5]{Images/L1_2.png}{Levels of Privelege}
\end{definition}

\subsubsection{System Calls Transition Between User and Kernel Mode}
\begin{definition}
    \customFigure[0.5]{Images/L1_3.png}{System Calls Transition}
\end{definition}

\subsubsection{Different Tpyes of Kernel Architectures}
\begin{definition}
    \begin{itemize}
        \item \textbf{Monolithic Kernel:} All the services are in the kernel.
        \customFigure[0.5]{Images/L1_4.png}{Monolithic Kernel}
        \item \textbf{Microkernel:} Only the essential services are in the kernel.
        \customFigure[0.5]{Images/L1_5.png}{Microkernel}
        \item \textbf{Hybrid Kernel:} A mix of monolithic and microkernel.
        \item \textbf{Nanokernel and picokernel:} Even smaller services than microkernel.
    \end{itemize}
\end{definition}

\begin{warning}
    Short answer question.
\end{warning}