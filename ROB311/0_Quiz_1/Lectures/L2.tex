\begin{summary}
    \begin{center}
        \begin{tabular}{llccccc}
        \toprule
        \textbf{Alg.} & Halting & Sound & Complete & Optimal & Time & Space \\
        \midrule
        \multicolumn{7}{p{\linewidth}}{
            Choose \texttt{REMOVE(Â·)} so algo. exhibits the characteristics:
            \begin{itemize}
                \item \textbf{Halting:} Terminates after finitely many nodes explored $\mid$ \textbf{Sound:} Returned (possibly NULL) soln. is correct 
                \item \textbf{Complete:} Halting \& sound when a non-NULL soln. exists $\mid$ \textbf{Opt.:} Returns an opt. soln. when mult. exist 
                \item \textbf{Time:} Minimizes nodes \textbf{explored}/expanded/exported $\mid$ \textbf{Space:} Minimizes nodes simultaneously open
            \end{itemize}} \\
        \midrule
        \multicolumn{7}{p{\linewidth}}{
            Choose \texttt{REMOVE($\cdot$)} so algo. exhibits the characteristics for as many path trees as possible. 
            \begin{itemize}
                \item $b$ ($b < \infty$): Branching factor (the maximum number of children a node can have)
                \item $d$: Depth (the length of the longest path), $l^*$: Length of the shortest solution
                \item $c^*$: Cost of the cheapest solution, $\epsilon$: Cost of the cheapest edge
            \end{itemize}} \\
        \midrule
        \multicolumn{7}{p{\linewidth}}{
        \begin{center}
            \textbf{Uninformed Search Algorithms}
        \end{center}} \\
        \midrule
        \textbf{BFS} & $d<\infty \mid$ non-\texttt{NULL} soln. & always & always & constant cst & $b^{l^{*}}$ & $b^{l^{*} + 1}$ \\
        \multicolumn{7}{p{\linewidth}}{
        \begin{itemize}
            \item Explores the least-recently expanded open node first.
        \end{itemize}} \\
        \midrule
        \textbf{DFS} & $d<\infty$ & always & $d < \infty$ & never & $b^{d}$ & $bd$ \\
        \multicolumn{7}{p{\linewidth}}{
        \begin{itemize}
            \item Explores the most-recently expanded open node first.
        \end{itemize}} \\
        \midrule
        \textbf{IDDFS} & always & always & always & constant cst & $b^{l^{*}}$ & $bl^{*}$ \\
        \multicolumn{7}{p{\linewidth}}{
        \begin{itemize}
            \item Same as DFS but with iterative deepening.
        \end{itemize}} \\
        \midrule
        \textbf{CFS} & $d<\infty \mid$ non-\texttt{NULL} soln. & yes & $\epsilon >0$ & $\epsilon >0$ & $b^{c^{*} / \epsilon}$ & $b^{c^{*}/\epsilon + 1}$ \\
        \multicolumn{7}{p{\linewidth}}{
        \begin{itemize}
            \item Explores the cheapest open node first.
        \end{itemize}} \\
        \midrule
        \multicolumn{7}{p{\linewidth}}{
        \begin{center}
            \textbf{Informed Search Algorithms}
        \end{center}} \\
        \midrule
        \textbf{HFS} & $d<\infty$ & never & never & never & - & - \\
        \multicolumn{7}{p{\linewidth}}{
        \begin{itemize}
            \item Explores the node with the smallest hur-value first, $\text{ecst}(p) = \text{hur}(p)$
        \end{itemize}} \\
        \midrule
        \textbf{A$^*$} & hur admissible, $\epsilon > 0$ & always & hur admissible, $\epsilon > 0$ & hur admissible, $\epsilon > 0$ & $O\left(b^{c^{*}/\epsilon}\right)$ & $O\left(b^{c^{*}/\epsilon + 1}\right)$ \\
        \multicolumn{7}{p{\linewidth}}{
        \begin{itemize}
            \item Explores the node with the smallest ecst-value first, $\text{ecst}(p) = \text{cst}(p) + \text{hur}(p)$
        \end{itemize}} \\
        \midrule
        \textbf{IIA$^*$} & always & always & always & always & $b^{l^{*}}$ & $bl^{*} $ \\
        \multicolumn{7}{p{\linewidth}}{
        \begin{itemize}
            \item Same as A$^*$ but with iterative inflating on ecst.
        \end{itemize}} \\
        \midrule
        \textbf{WA$^*$} & - & - & - & - & - & - \\
        \multicolumn{7}{p{\linewidth}}{
            \begin{itemize}
                \item Same as A$^*$ but $\text{ecst}(s) = \text{wcst}(s) + (1-w)\text{hur}(s)$ w/ $w \in [0,1]$
                \item $w=0$: HFS, $w=0.5$: A$^*$, $w=1$: CFS, iteratively increasing $w$ from 0 to 1: anytime version of $WA^*$
            \end{itemize}} \\
        \bottomrule
        \end{tabular}
    \end{center}
\end{summary}
\newpage

\subsection{Modifications to Search Algorithms:}
\begin{summary}
    \begin{center}
        \begin{tabular}{l}
        \toprule
        \textbf{Modifications} \\
        \midrule
        \textbf{Depth-Limiting} \\
        \multicolumn{1}{p{\linewidth}}{
        \begin{itemize}
            \item Enforce a depth limit, $d_{\text{max}}$, to any search algorithm.
        \end{itemize}} \\
        \midrule
        \textbf{Iterative-Deepening} \\
        \multicolumn{1}{p{\linewidth}}{
        \begin{itemize}
            \item Iteratively increase the depth-limit to any search algorithm w/ depth-limiting.
        \end{itemize}} \\
        \midrule
        \textbf{Cost-Limiting} \\
        \multicolumn{1}{p{\linewidth}}{
        \begin{itemize}
            \item Enforce a cost limit of $c_\text{max}$ to any search algorithm.
        \end{itemize}} \\
        \midrule
        \textbf{Iterative Inflating} \\
        \multicolumn{1}{p{\linewidth}}{
        \begin{itemize}
            \item Iteratively increase the cost limit, $c_{\text{max}}$, to any search algorithm w/ cost-limiting.
        \end{itemize}} \\
        \midrule
        \textbf{Intra-Path Cycle Checking} \\
        \multicolumn{1}{p{\linewidth}}{
        \begin{itemize}
            \item Do not expand a path if it is cyclic.
        \end{itemize}} \\
        \midrule
        \textbf{Inter-Path Cycle Checking} \\
        \multicolumn{1}{p{\linewidth}}{
        \begin{itemize}
            \item Do not expand a path if its destination is that of an explored path. 
        \end{itemize}} \\
        \bottomrule
        \end{tabular}
    \end{center}
\end{summary}
\newpage

\subsection{Setup}
\begin{definition} In a search problem, it is assumed that: 
    \begin{itemize}
        \item There is only one agent (us).
        \item For each state, $s \in S$, we have a discrete set of actions, $\mathcal{A}(s)$.
        \item The transition resulting from a move, $(s, a)$, is deterministic; the resulting state is $tr(s, a)$.
        \item $cst(s, a, tr(s, a))$ is our cost for the transition, $(s, a, tr(s, a))$.
        \item We want to realize a path that minimizes our cost.
    \end{itemize}
    
    A search problem may have no solutions, in which case, we define the solution as \texttt{NULL}.
\end{definition}

\begin{warning}
    A NULL solution is not the same as $p = \langle \rangle$ (an empty solution w/ $s^{(0)} \in \mathcal{G}$).
\end{warning}

\subsection{Search Graphs}
\begin{definition}
    In a search graph (a graph representing a search problem):
    \begin{itemize}
        \item $S$ is defined by the vertices.
        \item $\mathcal{G}$ is a subset of the vertices.
        \item $s^{(0)}$ is some vertex.
        \item $tr(\cdot, \cdot)$ and $\mathcal{T}$ are defined by the edges.
        \item $cst(\cdot, \cdot, \cdot)$ is defined by the edge weights.
    \end{itemize}
\end{definition}

\subsection{Path Trees}
\begin{definition}
    A search algorithm explores a tree of possible paths. 
    \begin{itemize}
        \item In such a tree, each node represents the path from the root to itself.
        \begin{itemize}
            \item The node may also include other info (such as the path's origin, cost, etc).
        \end{itemize}
    \end{itemize}
\end{definition}

\subsection{Search Algorithms}
\begin{algo}
    All search algorithms follow the template below:

\begin{lstlisting}
$\mathcal{O} \gets \{(\langle \rangle, 0)\}$ (*\hfill $\triangleright$ initialize a set of open nodes*) 
SEARCH($\mathcal{O}$)
\end{lstlisting}
\begin{itemize}
    \item $\langle \rangle$: Empty path, $0$: Cost of empty path.
\end{itemize}

\begin{lstlisting}
procedure SEARCH($\mathcal{O}$)
    if $\mathcal{O} = \emptyset$ then
        return NULL  (*\hfill $\triangleright$ the search algorithm failed to find a path to a goal*)
    $n \gets \textsc{Remove}(\mathcal{O})$ (*\hfill $\triangleright$ "explore" a node $n$*)
    if $\textsc{dst}(n) \in \mathcal{G}$ then
        return $n$ (*\hfill $\triangleright$ the search algorithm found a path to a goal*)
    for $n' \in \textsc{chl}(n)$ do (*\hfill $\triangleright$ "expand" $n$ and "export" its children*)
        $\mathcal{O} \gets \mathcal{O} \cup \{n'\}$ 
    SEARCH($\mathcal{O}$)
\end{lstlisting}
\begin{itemize}
    \item Explore: Remove a node from the open set.
    \item Expand: Generate the children of the node.
    \item Export: Add the children to the open set.
\end{itemize}

\end{algo}

\begin{warning}
    The key difference is in the order that \textsc{Remove}($\cdot$) removes nodes.
\end{warning}

\subsection{Modifications to Search Algorithms}
\subsubsection{Depth-Limiting}
\begin{algo}
\begin{lstlisting}
procedure SEARCHDL($\mathcal{O}$, $d_{\text{max}}$):
    if $\mathcal{O} = \emptyset$ then
        return NULL (*\hfill $\triangleright$ the search algorithm failed to find a path to a goal*)
    $n \leftarrow \text{REMOVE}(\mathcal{O})$ (*\hfill $\triangleright$ "explore" a node, $n$*)
    if dst($n$) $\in \mathcal{G}$ then
        return $n$ (*\hfill $\triangleright$ the search algorithm found a path to a goal*)
    for $n' \in \text{chl}(n)$ do (*\hfill $\triangleright$ "expand" $n$ and "export" its children*)
        if len($n'$) $\leq d_{\text{max}}$ then (*\hfill $\triangleright$ unless the child is too long*)
            $\mathcal{O} \leftarrow \mathcal{O} \cup \{n'\}$
    SEARCHDL($\mathcal{O}$, $d_{\text{max}}$)
\end{lstlisting}

\end{algo}

\subsubsection{Iterative Deepening}
\begin{algo}
\begin{lstlisting}
procedure SEARCHID():
    $n \leftarrow \text{NULL}$
    $d_{\text{max}} = 0$
    (*$\triangleright$ while a solution has not been found, reset the open set, run the search algorithm, then increase the depth-limit*)
    while $n = \text{NULL}$ do
        $\mathcal{O} \leftarrow \{(\langle \rangle, 0)\}$
        $n \leftarrow \text{SEARCHDL}(\mathcal{O}, d_{\text{max}})$
        $d_{\text{max}} \leftarrow d_{\text{max}} + 1$
    return $n$
\end{lstlisting}
    
\end{algo}

\begin{warning}
    Increasing $d_{\text{max}}$ can be done in different ways.
\end{warning}

\subsubsection{Cost-Limiting}
\begin{algo}

\begin{lstlisting}
procedure SEARCHCL($\mathcal{O}$, $c_{\text{max}}$):
    if $\mathcal{O} = \emptyset$ then
        return NULL (*\hfill $\triangleright$ the search algorithm failed to find a path to a goal*)
    $n \leftarrow \text{REMOVE}(\mathcal{O})$ (*\hfill $\triangleright$ "explore" a node, $n$*)
    if dst($n$) $\in \mathcal{G}$ then
        return $n$ (*\hfill $\triangleright$ the search algorithm found a path to a goal*)
    for $n' \in \text{chl}(n)$ do (*\hfill $\triangleright$ "expand" $n$ and "export" its children*)
        if cst($n'$) $\leq c_{\text{max}}$ then (*\hfill $\triangleright$ unless the child is too expensive*)
            $\mathcal{O} \leftarrow \mathcal{O} \cup \{n'\}$
    SEARCHCL($\mathcal{O}$, $c_{\text{max}}$)
\end{lstlisting}

\end{algo}
\newpage

\subsubsection{Iterative-Inflating}
\begin{algo}
\begin{lstlisting}
procedure SEARCHII():
    $n \leftarrow \text{NULL}$
    $c_{\text{max}} = 0$
    (*$\triangleright$ while a solution has not been found, reset the open set, run the search algorithm, then increase the cost-limit*)
    while $n = \text{NULL}$ do
        $\mathcal{O} \leftarrow \{(\langle \rangle, 0)\}$
        $n \leftarrow \text{SEARCHCL}(\mathcal{O}, c_{\text{max}})$
        $c_{\text{max}} \leftarrow c_{\text{max}} + \epsilon$
    return $n$
\end{lstlisting}

\end{algo}

\begin{warning}
    Increasing $c_{\text{max}}$ can be done in different ways.
\end{warning}

\subsubsection{Intra-Path Cycle Checking}
\begin{algo}
\begin{lstlisting}
procedure SEARCH($\mathcal{O}$):
    if $\mathcal{O} = \emptyset$ then
        return NULL
    $n \leftarrow \text{REMOVE}(\mathcal{O})$
    if dst($n$) $\in \mathcal{G}$ then
        return $n$
    for $n' \in \text{chl}(n)$ do (*\hfill $\triangleright$ "expand" $n$ and "export" its children*)
        if not CYCLIC($n'$) then (*\hfill $\triangleright$ unless the child is cyclic*)
            $\mathcal{O} \leftarrow \mathcal{O} \cup \{n'\}$
    SEARCH($\mathcal{O}$)
\end{lstlisting}
\begin{itemize}
    \item Optimately of an algorithm is preserved provided $\epsilon>0$.
\end{itemize}
\end{algo}

\subsubsection{Inter-Path Cycle Checking}
\begin{algo}
\begin{lstlisting}
procedure SEARCH($\mathcal{O}$, $\mathcal{C}$):
    if $\mathcal{O} = \emptyset$ then
        return NULL
    $n \leftarrow \text{REMOVE}(\mathcal{O})$
    $\mathcal{C} \leftarrow \mathcal{C} \cup \{n\}$ (*\hfill $\triangleright$ add $n$ to the closed set*)
    if dst($n$) $\in \mathcal{G}$ then
        return $n$
    for $n' \in \text{chl}(n)$ do (*\hfill $\triangleright$ "expand" $n$ and "export" its children*)
        if $n' \notin \mathcal{C}$ then (*\hfill $\triangleright$ unless the child's destination is closed*)
            $\mathcal{O} \leftarrow \mathcal{O} \cup \{n'\}$
    SEARCH($\mathcal{O}$, $\mathcal{C}$)
\end{lstlisting}

and then call the algorithm as follows:

\begin{lstlisting}[mathescape=true, escapeinside={(*}{*)}, numbers=left, frame=single]
$\mathcal{O} \leftarrow \{(\langle \rangle, 0)\}$
$\mathcal{C} \leftarrow \{\}$ (*\hfill $\triangleright$ initialize a set of closed vertices*)
SEARCH($\mathcal{O}$, $\mathcal{C}$)
\end{lstlisting}

\end{algo}
\newpage

\subsection{Informed Search Algorithms}
\subsubsection{Estimated Cost}
\begin{definition}
    $\text{ecst}(\cdot)$: estimate the total cost to a goal given a path, $p$, based on:
    \begin{itemize}
        \item $\text{cst}(p)$: Cost of path $p$
        \item $\text{hur}: S \to \mathbb{R}_+$: Estimate of the extra cost needed to get to a goal from $\text{dst}(p)$
        \begin{itemize}
            \item $\text{hur}(s)$ estimates the cost to get to $\mathcal{G}$ from $s$ and $\text{hur}(p)$ means $\text{hur}(\text{dst}(p))$.
            \item $\text{hur}^*(s)$: The true cost to get to $\mathcal{G}$ from $s$.
        \end{itemize}
    \end{itemize}
\end{definition}

\subsubsection{Admissible}
\begin{motivation}
    We want to find a heuristic that under estimates (i.e. make paths look better than they are) the costs, rather than over estimate (i.e. make paths look worse than they are).
    \begin{itemize}
        \item Least useful heuristic: $\text{hur}(s) = 0$ for all $s \in \mathcal{S}$ or any other constant.
        \item Most useful heuristic: $\text{hur}(s) = \text{hur}^*(s)$ for all $s \in \mathcal{S}$.
    \end{itemize}
\end{motivation}
\begin{definition}
    A heuristic, $\text{hur}(\cdot)$, is said to be \textbf{admissible} if

    \begin{equation*}
        \text{hur}(s) \leq \text{hur}^*(s)
    \end{equation*}

    for all $s \in \mathcal{S}$ and

    \begin{equation*}
        \text{hur}(s) = 0
    \end{equation*}

    for all $s \in \mathcal{G}$.
\end{definition}

\begin{warning}
    Never over-estimates the overall cost, but may still estimate the cost of individual transition. 
\end{warning}

\subsubsection{Consistent}
\begin{definition}
    A heuristic, $\text{hur}(\cdot)$, is said to be \textbf{consistent} if

    \begin{equation*}
        \underbrace{\text{hur}(s) - \text{hur}(\text{tr}(s,a))}_{\text{estimated cost of the transition }(s,a,\text{tr}(s,a))}
        \leq 
        \underbrace{\text{cst}(s,a,\text{tr}(s,a))}_{\text{true cost of the transition, }(s,a,\text{tr}(s,a))}
    \end{equation*}

    for all $s \in \mathcal{S}$, and $a \in \mathcal{A}(s)$, and

    \begin{equation*}
        \text{hur}(s) = 0
    \end{equation*}

    for all $s \in \mathcal{G}$.
\end{definition}

\begin{warning}
    Never over-estimates the cost of individual transitions (and hence the overall cost).
\end{warning}

\begin{theorem}
    If a heuristic, $\text{hur}(\cdot)$, is consistent, then it is also admissible.
\end{theorem}
\newpage

\subsubsection{Domination}
\begin{definition}
    If $\text{hur}_1$ and $\text{hur}_2$ are admissible, then:
    \begin{itemize}
        \item $\text{hur}_1$ \textbf{strongly dominates} $\text{hur}_2$ if for all $s \in \mathcal{S} \setminus \mathcal{G}$:
        \begin{equation*}
            \text{hur}_1(s) > \text{hur}_2(s)
        \end{equation*}

        \item $\text{hur}_1$ \textbf{weakly dominates} $\text{hur}_2$ if for all $s \in \mathcal{S}$:
        \begin{equation*}
            \text{hur}_1(s) \geq \text{hur}_2(s)
        \end{equation*}
        and for some $s \in \mathcal{S}$:
        \begin{equation*}
            \text{hur}_1(s) > \text{hur}_2(s)
        \end{equation*}
    \end{itemize}
\end{definition}

\begin{notes}
    Want the heuristic that dominates but is also admissible.
\end{notes}

\subsubsection{Designing Heuristics via Problem Relaxation}
\begin{definition}
    Let $\text{hur}^*_{\text{ori}}$ be the perfect heuristic for a search problem, and $\text{cst}^*_{\text{rel}}$ be the optimal cost for a relaxed version of the problem. Then
    \[
    \text{cst}^*_{\text{rel}}(s) \leq \text{hur}^*_{\text{ori}}(s) \text{ for all } s \in \mathcal{S}.
    \]
\end{definition}

\subsubsection{Combining Heuristics}
\begin{definition}
    If $\{ \text{hur}_k(\cdot) \}_k$ are admissible (or consistent), then $\max_k \{\text{hur}_k\} (\cdot)$ is also admissible (or consistent).
\end{definition}

\begin{definition}
    If $\text{hur}_{\max} \equiv \max \{\text{hur}_1, \text{hur}_2\}$, then if $\text{hur}_k$ is consistent:
    \[
    \text{hur}_k(s) - \text{hur}_k(\text{tr}(s,a)) \leq \text{cst}(s,a,\text{tr}(s,a))
    \]
    \[
    \text{hur}_{\max} (s)= \text{hur}_{\max}(\text{tr}(s,a)) - \text{cst}^*(s,a,\text{tr}(s,a))
    \]
\end{definition}

\subsubsection{Anytime Search Algorithms}
\begin{definition}
    An \textbf{anytime algorithm} finds a solution quickly (even if it is sub-optimal), and then iteratively improves it (if time permits).
\end{definition}
\newpage

\subsection{Canonical Examples}
\subsubsection{How to setup a search problem?}
\begin{process} 
    \begin{enumerate}
        \item Given a search graph, we need to define the following:
        \begin{itemize}
            \item $\mathcal{S}$: set of vertices
            \item $\mathcal{G}$: goal states (subset of $\mathcal{S}$)
            \item $s^{(0)}$: initial state
            \item $\mathcal{T}$: set of edges (defined by $\text{tr}(\cdot, \cdot)$)
            \begin{itemize}
                \item $\text{tr}(\cdot, \cdot)$: transition function
            \end{itemize}
            \item $\text{cst}(\cdot, \cdot, \cdot)$: cost function (defined by edge weights)
        \end{itemize}
    \end{enumerate}
\end{process}

\begin{example}
    \customFigure[0.5]{../Images/L2_0.png}{}
    \customFigure[0.5]{../Images/L2_1.png}{}
\end{example}
\newpage

\begin{example}
    \customFigure[0.5]{../Images/L2_9.png}{}
    \customFigure[0.5]{../Images/L2_10.png}{}
    \begin{itemize}
        \item $\mathcal{S} = \{0,\ldots,4 \}^2$
        \item $\mathcal{G} = \left\{ \begin{bmatrix}
            1 \\
            4
        \end{bmatrix} \right\}$
        \item $s^{(0)} = \begin{bmatrix}
            1 \\
            0
        \end{bmatrix}$
    \end{itemize}
\end{example}
\newpage

\subsubsection{How to setup a path tree?}
\begin{process} 
    \begin{enumerate}
        \item Start at $s^{(0)}$
        \item Choose a path until you reach a goal state.
        \item Repeat until you have found all paths (probably infinite).
    \end{enumerate}
\end{process}

\begin{example}
    \customFigure[0.5]{../Images/L2_2.png}{}
    \customFigure[0.5]{../Images/L2_3.png}{}
\end{example}

\newpage

\subsubsection{When to use each algorithm?}
\begin{process} 
    \begin{enumerate}
        \item Do we have a heuristic?
        \begin{itemize}
            \item \textbf{Yes:} Use informed search algorithms.
            \item \textbf{No:} Use uninformed search algorithms.
        \end{itemize}
        \item  Are path costs non-uniform?
        \begin{itemize}
            \item \textbf{Yes:} Eliminate BFS.
            \item \textbf{No:} Eliminate CFS, $A*$
        \end{itemize}
        \item 
        \item Is the search space finite or infinite? 
        \begin{itemize}
            \item \textbf{Finite:} Use any algorithm.
            \item \textbf{Infinite:} Use BFS, IDDFS, CFS, or A*.
        \end{itemize}
        \item Do we need to guarantee finding a solution (completeness)?
        \begin{itemize}
            \item \textbf{Yes:} Use BFS, IDDFS, IIA*, CFS (if $\epsilon > 0$).
            \item \textbf{No:} Use DFS, HFS, WA*
        \end{itemize}
        \item Find properties needed for the problem and match them to the characteristics of the algorithm.
        \item Choose the algorithm that best matches the properties.
        \begin{itemize}
            \item \textbf{BFS:} Need shortest path in an unweighted graph. 
            \item \textbf{DFS:} Explore a deep path quickly, and completeness is not needed.
            \item \textbf{IDDFS:} Want completeness of BFS but with the complexity of DFS.
            \item \textbf{CFS:} Need the least-cost path in a weighted graph. 
            \item \textbf{HFS:}
            \item \textbf{A*:} 
            \item \textbf{IIA*:}
            \item \textbf{WA*:}
        \end{itemize}
    \end{enumerate}
\end{process}

\begin{example}
    
\end{example}
\newpage

\subsubsection{Tracing Search Algorithms}
\begin{example}
    \customFigure[0.5]{../Images/LR_0.png}{}
\end{example}
\newpage

\begin{process} \textbf{BFS}
    \begin{enumerate}
        \item Start at $s_0$ as \textbf{current node}
        \item Expand all neighboring nodes of the \textbf{current node} and add them to the open set (queue).
        \item Remove the \textbf{current node} from the open set and add it to the path. 
        \item Choose the least-recently expanded node from the open set as the \textbf{current node}.
        \item Repeat steps 2 and 4 until the goal state is reached or the open set is empty.
    \end{enumerate}
\end{process}

\begin{example} \textbf{BFS}
    \begin{center}
        \begin{tabular}{ll}
        \toprule
        \textbf{Path} & \textbf{Open Set} \\
        \midrule
         & $\{A\}$ \\
        $A$ & $\{AB, AC, AD\}$ \\
        $AB$ & $\{AC, AD, ABA, ABC\}$ \\
        $AC$ & $\{AD, ABA, ABC, ACD, ACE\}$ \\
        $AD$ & $\{ABA, ABC, ACD, ACE, ADA, ADE\}$ \\
        $ABA$ & $\{ABC, ACD, ACE, ADA, ADE, ABAB, ABAC, ABAD\}$ \\
        $ABC$ & $\{ACD, ACE, ADA, ADE, ABAB, ABAC, ABAD, ABCD, ABCE\}$ \\
        $ACD$ & $\{ACE, ADA, ADE, ABAB, ABAC, ABAD, ABCD, ABCE, ACDA, ACDE\}$ \\
        $ACE$ & $\{ADA, ADE, ABAB, ABAC, ABAD, ABCD, ABCE, ACDA, ACDE\}$ \\
        \bottomrule
        \end{tabular}
    \end{center}
    \vspace{1em}

    \textbf{Intra:}
    \begin{center}
        \begin{tabular}{ll}
        \toprule
        \textbf{Path} & \textbf{Open Set} \\
        \midrule
         & $\{A\}$ \\
        $A$ & $\{AB, AC, AD\}$ \\
        $AB$ & $\{AC, AD, ABC, \cancel{ABA}\}$ \\
        $AC$ & $\{AD, ABC, ACD, ACE\}$ \\
        $AD$ & $\{ABC, ACD, ACE, ADE, \cancel{ADA}\}$ \\
        $ABC$ & $\{ACD, ACE, ADE, ABCD, ABCE\}$ \\
        $ACD$ & $\{ACE, ADE, ABCD, ABCE, ACDE, \cancel{ACBA}\}$ \\
        $ACE$ & $\{ADE, ABCD, ABCE, ACDE\}$ \\
        \bottomrule
        \end{tabular}
    \end{center}
    \vspace{1em}

    \textbf{Inter:}
    \begin{center}
        \begin{tabular}{lll}
        \toprule
        \textbf{Path} & \textbf{Open Set} & \textbf{Closed Set} \\
        \midrule
        - & $\{A\}$ & - \\
        $A$ & $\{AB, AC, AD\}$ & $\{A\}$ \\
        $AB$ & $\{AC, AD, ABC, \cancel{ABA}\}$ & $\{A, B\}$ \\
        $AC$ & $\{AD, ABC, ACD, ACE\}$ & $\{A, B, C\}$ \\
        $AD$ & $\{ABC, ACD, ACE, ADE, \cancel{ADA}\}$ & $\{A, B, C, D\}$ \\
        $ABC$ & $\{ACD, ACE, ADE, ABCE, \cancel{ABCD}\}$ & $\{A, B, C, D\}$ \\
        $ACD$ & $\{ACE, ADE, ABCE, ACDE, \cancel{ACDA}\}$ & $\{A, B, C, D\}$ \\
        $ACE$ & $\{ADE, ABCE, ACDE\}$ & $\{A, B, C, D, E\}$ \\
        \bottomrule
        \end{tabular}
    \end{center}
\end{example}
\newpage



\begin{process} \textbf{DFS}
    \begin{enumerate}
        \item Start at $s_0$ as \textbf{current node}
        \item Expand all neighboring nodes of the \textbf{current node} and add them to the open set (stack).
        \item Remove the \textbf{current node} from the open set and add it to the path. 
        \item Choose the most-recently expanded node from the open set as the \textbf{current node}.
        \item Repeat steps 2 and 4 until the goal state is reached or the open set is empty.
    \end{enumerate}
\end{process}

\begin{example} \textbf{DFS}
    \begin{center}
        \begin{tabular}{ll}
        \toprule
        \textbf{Path} & \textbf{Open Set} \\
        \midrule
         & $\{A\}$ \\
        $A$ & $\{AB,AC,AD\}$ \\
        $AD$ & $\{AB,AC,ADA,ADE\}$ \\
        $ADE$ & $\{AB, AC,ADA\}$ \\
        \bottomrule
        \end{tabular}
    \end{center}
    \vspace{1em}

    \textbf{Intra:}
    \begin{center}
        \begin{tabular}{lll}
        \toprule
        \textbf{Path} & \textbf{Open Set} \\
        \midrule
        - & $\{A\}$ \\
        $A$ & $\{AB,AC,AD\}$ \\
        $AD$ & $\{AB,AC,ADE, \cancel{ADA}\}$ \\
        $ADE$ & $\{AB, AC\}$ \\
        \bottomrule
        \end{tabular}
    \end{center}
    \vspace{1em}

    \textbf{Inter:}
    \begin{center}
        \begin{tabular}{lll}
        \toprule
        \textbf{Path} & \textbf{Open Set} & \textbf{Closed Set} \\
        \midrule
        - & $\{A\}$ & - \\
        $A$ & $\{AB,AC,AD\}$ & $\{A\}$ \\
        $AD$ & $\{AB,AC,ADE, \cancel{ADA}\}$ & $\{A, D\}$ \\
        $ADE$ & $\{AB, AC\}$ & $\{A, D, E\}$ \\
        \bottomrule
        \end{tabular}
    \end{center}
\end{example}
\newpage

\begin{process} \textbf{IDDFS}
    \begin{enumerate}
        \item Start with a depth limit of 0.
        \item Perform DFS up to the current depth limit.
        \item If the goal state is not reached, increment the depth limit based on given fcn and repeat step 2.
        \item Continue until the goal state is found or all nodes are explored.
    \end{enumerate}
\end{process}

\begin{example} \textbf{IDDFS}
    \begin{center}
        \begin{tabular}{lll}
        \toprule
        \textbf{Depth} & \textbf{Path} & \textbf{Open Set} \\
        \midrule
        0 & & $\{A\}$ \\
        0 & A & $\{\}$ \\
        \midrule
        1 & $A$ & $\{AB, AC, AD\}$ \\
        1 & $AD$ & $\{AB, AC\}$ \\
        1 & $AC$ & $\{AB\}$ \\
        1 & $AB$ & $\{\}$ \\
        \midrule
        2 & $AB$ & $\{ABA, ABC\}$ \\
        2 & $ABC$ & $\{ABA\}$ \\
        2 & $ABA$ & $\{\}$ \\
        \midrule
        3 & $ABA$ & $\{ABAB, ABAC, ABAD\}$ \\
        3 & $ABAB$ & $\{ABAC, ABAD\}$ \\
        3 & $ABAC$ & $\{ABAD\}$ \\
        3 & $ABAD$ & $\{\}$ \\
        \midrule
        4 & $ABAD$ & $\{ABADA, ABADE\}$ \\
        4 & $ABADA$ & $\{ABADE\}$ \\
        4 & $ABADE$ & $\{\}$ \\
        \bottomrule
        \end{tabular}
    \end{center}
\end{example}
\newpage

\begin{process} \textbf{CFS}
    \begin{enumerate}
        \item Start at $s_0$ as \textbf{current node}
        \item Expand all neighboring nodes of the \textbf{current node} and add them to the open set (priority queue).
        \item Remove the \textbf{current node} from the open set and add it to the path. 
        \item Choose the cheapest expanded node from the open set as the \textbf{current node}.
        \item Repeat steps 2 and 4 until the goal state is reached or the open set is empty.
    \end{enumerate}
\end{process}

\begin{example} \textbf{CFS}
    \begin{center}
        \begin{tabular}{ll}
        \toprule
        \textbf{Path} & \textbf{Open Set} \\
        \midrule
        - & $\{A \mid 0\}$ \\
        $A$ & $\{AB \mid 2, \; AC \mid 4, \; AD \mid 6\}$ \\
        $AB$ & $\{AC \mid 4, \; AD \mid 6, \; ABC \mid 3, \; ABA \mid 4\}$ \\
        $ABC$ & $\{AC \mid 4, \; AD \mid 6, \; ABA \mid 4, \; ABCE \mid 5, \; ABCD \mid 6\}$ \\
        $AC$ & $\{AD \mid 6, \; ABA \mid 4, \; ABCE \mid 5, \; ABCD \mid 6, \; ACD \mid 7, \; ACE \mid 6\}$ \\
        $ABA$ & $\{AD \mid 6, \; ABCE \mid 5, \; ABCD \mid 6, \; ACD \mid 7, \; ACE \mid 6, \; ABAB \mid 6, \; ABAC \mid 8, \; ABAD \mid 10\}$ \\
        $ABCE$ & $\{AD \mid 6, \; ABCD \mid 6, \; ACD \mid 7, \; ACE \mid 6, \; ABAB \mid 6, \; ABAC \mid 8, \; ABAD \mid 10\}$ \\
        \bottomrule
        \end{tabular}
    \end{center}
    \vspace{1em}

    \textbf{Intra:}
    \begin{center}
        \begin{tabular}{ll}
        \toprule
        \textbf{Path} & \textbf{Open Set} \\
        \midrule
        - & $\{A \mid 0\}$ \\
        $A$ & $\{AB \mid 2, \; AC \mid 4, \; AD \mid 6\}$ \\
        $AB$ & $\{AC \mid 4, \; AD \mid 6, \; ABC \mid 3, \; \cancel{ABA} \}$ \\
        $ABC$ & $\{AC \mid 4, \; AD \mid 6, \; ABCE \mid 5, \; ABCD \mid 6\}$ \\
        $AC$ & $\{AD \mid 6, \; ABCE \mid 5, \; ABCD \mid 6, \; ACD \mid 7, \; ACE \mid 6\}$ \\
        $ABCE$ & $\{AD \mid 6, \; ABCD \mid 6, \; ACD \mid 7, \; ACE \mid 6\}$ \\
        \bottomrule
        \end{tabular}
    \end{center}
    \vspace{1em}

    \textbf{Inter:}
    \begin{center}
        \begin{tabular}{lll}
        \toprule
        \textbf{Path} & \textbf{Open Set} & \textbf{Closed Set} \\
        \midrule
        - & $\{A \mid 0\}$ & - \\
        $A$ & $\{AB \mid 2, \; AC \mid 4, \; AD \mid 6\}$ & $\{A\}$ \\
        $AB$ & $\{AC \mid 4, \; AD \mid 6, \; ABC \mid 3, \; \cancel{ABA} \} $ & $\{A, B\}$ \\
        $ABC$ & $\{AC \mid 4, \; AD \mid 6, \; ABCE \mid 5, \; ABCD \mid 6\} $ & $\{A, B, C\}$ \\
        $AC$ & $\{AD \mid 6, \; ABCE \mid 5, \; ABCD \mid 6, \; ACD \mid 7, \; ACE \mid 6\}$ & $\{A, B, C\}$ \\
        $ABCE$ & $\{AD \mid 6, \; ABCD \mid 6, \; ACD \mid 7, \; ACE \mid 6\}$ & $\{A, B, C, E\}$ \\
        \bottomrule
        \end{tabular}
    \end{center}
\end{example}
\newpage

\begin{process} \textbf{HFS}
    \begin{enumerate}
        \item Start at $s_0$ as \textbf{current node}
        \item Expand all neighboring nodes of the \textbf{current node} and add them to the open set (priority queue).
        \item Remove the \textbf{current node} from the open set and add it to the path. 
        \item Choose the lowest heuristic value expanded node from the open set as the \textbf{current node}.
        \item Repeat steps 2 and 4 until the goal state is reached or the open set is empty.
    \end{enumerate}
\end{process}

\begin{example} \textbf{HFS}
    \begin{center}
        \begin{tabular}{ll}
        \toprule
        \textbf{Path} & \textbf{Open Set} \\
        \midrule
         & $\{A \mid 3\}$ \\
        $A$ & $\{AB \mid 2, \; AC \mid 1, \; AD \mid 1\}$ \\
        $AC$ & $\{AB \mid 2, \; AD \mid 1, \; ACE \mid 0\}$ \\
        $ACE$ & $\{AB \mid 2, \; AD \mid 1\}$ \\
        \bottomrule
        \end{tabular}
    \end{center}
\end{example}
\newpage


\begin{process} \textbf{A$^*$}
    \begin{enumerate}
        \item Start at $s_0$ as \textbf{current node}
        \item Expand all neighboring nodes of the \textbf{current node} and add them to the open set (priority queue).
        \item Remove the \textbf{current node} from the open set and add it to the path. 
        \item Choose the lowest $\text{esct}(p) = \text{cst}(p) + \text{hur}(p)$ expanded node from the open set as the \textbf{current node}.
        \item Repeat steps 2 and 4 until the goal state is reached or the open set is empty.
    \end{enumerate}
\end{process}

\begin{example} \textbf{A$^*$}
    \begin{center}
        \begin{tabular}{ll}
        \toprule
        \textbf{Path} & \textbf{Open Set} \\
        \midrule
        - & $\{A \mid 3 \}$ \\
        $A$ & $\{AB \mid 2 + 2, \; AC \mid 4 + 1, \; AD \mid 6 + 1\}$ \\
        $AB$ & $\{AC \mid 5, \; AD \mid 7, \; ABC \mid (2 + 1) + 1, \; ABA \mid (2 + 2) + 3 \}$ \\
        $ABC$ & $\{AC \mid 5, \; AD \mid 7, \; ABA \mid 7, \; ABCD \mid (2 + 1 + 3) + 1, \; ABCE \mid (2 + 1 + 2) + 0, \}$ \\
        $AC$ & $\{AD \mid 7, \; ABA \mid 7, \; ABCD \mid 7, \; ABCE \mid 5, \; ACD \mid (4 + 3) + 1, \; ACE \mid (4 + 2) + 0\}$ \\
        $ABCE$ & $\{AD \mid 7, \; ABA \mid 7, \; ABCD \mid 7, \; ACD \mid 8, \; ACE \mid 6 \}$ \\
        \bottomrule
        \end{tabular}
    \end{center}
    \vspace{1em}

    \textbf{Intra:}
    \begin{center}
        \begin{tabular}{ll}
        \toprule
        \textbf{Path} & \textbf{Open Set} \\
        \midrule
        - & $\{A \mid 3 \}$ \\
        $A$ & $\{AB \mid 2 + 2, \; AC \mid 4 + 1, \; AD \mid 6 + 1\}$ \\
        $AB$ & $\{AC \mid 5, \; AD \mid 7, \; ABC \mid (2 + 1) + 1, \; \cancel{ABA} \}$ \\
        $ABC$ & $\{AC \mid 5, \; AD \mid 7, \; ABCD \mid (2 + 1 + 3) + 1, \; ABCE \mid (2 + 1 + 2) + 0, \}$ \\
        $AC$ & $\{AD \mid 7, \; ABCD \mid 7, \; ABCE \mid 5, \; ACD \mid (4 + 3) + 1, \; ACE \mid (4 + 2) + 0\}$ \\
        $ABCE$ & $\{AD \mid 7, \; ABCD \mid 7, \; ACD \mid 8, \; ACE \mid 6 \}$ \\
        \bottomrule
        \end{tabular}
    \end{center}
    \vspace{1em}

    \textbf{Inter:}
    \begin{center}
        \begin{tabular}{lll}
        \toprule
        \textbf{Path} & \textbf{Open Set} & \textbf{Closed Set} \\
        \midrule
        - & $\{A \mid 3 \}$ & - \\
        $A$ & $\{AB \mid 2 + 2, \; AC \mid 4 + 1, \; AD \mid 6 + 1\}$ & $\{A\}$ \\
        $AB$ & $\{AC \mid 5, \; AD \mid 7, \; ABC \mid (2 + 1) + 1, \; \cancel{ABA} \}$ & $\{A, B\}$ \\
        $ABC$ & $\{AC \mid 5, \; AD \mid 7, \; ABCD \mid (2 + 1 + 3) + 1, \; ABCE \mid (2 + 1 + 2) + 0, \}$ & $\{A, B, C\}$ \\
        $AC$ & $\{AD \mid 7, \; ABCD \mid 7, \; ABCE \mid 5, \; ACD \mid (4 + 3) + 1, \; ACE \mid (4 + 2) + 0\}$ & $\{A, B, C\}$ \\
        $ABCE$ & $\{AD \mid 7, \; ABCD \mid 7, \; ACD \mid 8, \; ACE \mid 6 \}$ & $\{A, B, C, E\}$ \\
        \bottomrule
        \end{tabular}
    \end{center}
\end{example}
\newpage

\begin{process} \textbf{IIA*}
    \begin{enumerate}
        \item Start with a cost limit of 0.
        \item Perform A* up to the current cost limit.
        \item If the goal state is not reached, increment the cost limit based on given fcn and repeat step 2.
        \item Continue until the goal state is found or all nodes are explored.
    \end{enumerate}
\end{process}

\begin{example} \textbf{IIA*}
    \begin{center}
        \begin{tabular}{lll}
        \toprule
        \textbf{Cost} & \textbf{Path} & \textbf{Open Set} \\
        \midrule
        0 & $\langle \rangle$ & $\{\}$ \\
        \midrule
        1 & $\langle \rangle$ & $\{\}$ \\
        \midrule
        2 & $\langle \rangle$ & $\{\}$ \\
        \midrule
        3 & $\langle \rangle$ & $\{A \mid 3\}$ \\
        3 & $A$ & $\{\}$ \\
        \midrule
        4 & $A$ & $\{AB \mid 2 + 2\}$ \\
        4 & $AB$ & $\{ABC \mid 3 + 1\}$ \\
        4 & $ABC$ & $\{\}$ \\
        \midrule
        5 & $ABC$ & $\{ABCE \mid 5 + 0\}$ \\
        5 & $ABCE$ & $\{\}$ \\
        \bottomrule
        \end{tabular}
    \end{center}
\end{example}

\begin{process} \textbf{WA*}
    \begin{enumerate}
        \item Start at $s_0$ as \textbf{current node}
        \item Expand all neighboring nodes of the \textbf{current node} and add them to the open set (priority queue).
        \item Remove the \textbf{current node} from the open set and add it to the path. 
        \item Choose the lowest $\text{esct}(p) =  w \cdot \text{cst}(p) + (1-w) \cdot \text{hur}(p)$ expanded node from the open set as the \textbf{current node}.
        \item Repeat steps 2 and 4 until the goal state is reached or the open set is empty.
    \end{enumerate}
\end{process}
\newpage

\begin{process} \textbf{How to Prove Consistent/Admissible Given a Search Graph?}
   
    \textbf{Admissible:}
    \begin{enumerate}
        \item Given $\text{hur}(s)$ and search graph with $\text{cst}(s,a,\text{tr}(s,a))$. If consistent, then it is admissible.
        \item Check $\forall s \in \mathcal{G}$, $\text{hur}(s) = 0$. If not, then it is not admissible.
        \item For each $s \in \mathcal{S}$, calculate $\text{hur}^*(s)$ (i.e. actual cost of optimal soln.) using the search graph.
        \begin{enumerate}
            \item Start at $s$ and choose path that gives the lowest cost to $s \in \mathcal{G}$. 
        \end{enumerate}
        \item Check if $\text{hur}(s) \leq \text{hur}^*(s) \; \forall s \in \mathcal{S}$. If not, then it is not admissible.
        \item Repeat $\forall s \in \mathcal{S}$. 
        \item If all are true, then it is admissible.
    \end{enumerate}
    \vspace{1em}

    \textbf{Consistent:}
    \begin{enumerate}
        \item Given $\text{hur}(s)$ and search graph with $\text{cst}(s,a,\text{tr}(s,a))$. 
        \item Check $\forall s \in \mathcal{G}$, $\text{hur}(s) = 0$. If not, then it is not consistent.
        \item For each $s \in \mathcal{S}$, calculate $\text{hur}(s) - \text{hur}(\text{tr}(s, a))$.
        \begin{enumerate}
            \item check if it is $\leq \text{cst}(s,a,\text{tr}(s,a))$. If not, then it is not consistent.
            \item Repeat $\forall a \in \mathcal{A}(s)$
        \end{enumerate}
        \item Repeat $\forall s \in \mathcal{S}$.
        \item If all are true, then it is consistent.
    \end{enumerate}
\end{process}

\begin{warning}
    Be careful of bidirectional edges bc for consistency you need compute the cost of the heuristic edge in both directions.
\end{warning}
\newpage

\begin{example}
    \customFigure[0.5]{../Images/L2_8.png}{Jungle ($s^{(0)}$), Desert, Swamp, Mountain, Plains (Goal)}

    \textbf{Admissible:}
    \begin{enumerate}
        \item \textbf{$s=$Plains:} $\text{hur}(\text{Plains}) = 0$ 
        \item \textbf{$s=$Jungle:} $\text{hur}(\text{Jungle}) = 3 \leq \text{hur}^*(\text{Jungle}) = 2 + 1 + 2 = 5$
        \item \textbf{$s=$Desert:} $\text{hur}(\text{Desert}) = 2 \leq \text{hur}^*(\text{Desert}) = 1 + 2$
        \item \textbf{$s=$Swamp:} $\text{hur}(\text{Swamp}) = 1 \leq \text{hur}^*(\text{Swamp}) = 2$
        \item \textbf{$s=$Mountain:} $\text{hur}(\text{Mountain}) = 1 \leq \text{hur}^*(\text{Mountain}) = 1$
        \item Therefore, it is admissible.
    \end{enumerate}
    \vspace{1em}

    \textbf{Consistent:}
    \begin{enumerate}
        \item \textbf{$s=$Plains:} $\text{hur}(\text{Plains}) = 0$
        \item \textbf{$s=$Jungle:}
        \begin{enumerate}
            \item $\text{hur}(\text{Jungle}) - \text{hur}(\text{Desert}) = 3 - 2 = 1 \leq \text{cst}(\text{Jungle}, \cdot, \text{Desert}) = 2$
            \item $\text{hur}(\text{Jungle}) - \text{hur}(\text{Swamp}) = 3 - 1 = 2 \leq \text{cst}(\text{Jungle}, \cdot, \text{Swamp}) = 4$
            \item $\text{hur}(\text{Jungle}) - \text{hur}(\text{Mountain}) = 3 - 1 = 2 \leq \text{cst}(\text{Jungle}, \cdot, \text{Mountain}) = 6$
        \end{enumerate}
        \item \textbf{$s=$Desert:} 
        \begin{enumerate}
            \item $\text{hur}(\text{Desert}) - \text{hur}(\text{Jungle}) = 2 - 3 = -1 \leq \text{cst}(\text{Desert}, \cdot, \text{Jungle}) = 2$
            \item $\text{hur}(\text{Desert}) - \text{hur}(\text{Swamp}) = 2 - 1 = 1 \leq \text{cst}(\text{Desert}, \cdot, \text{Swamp}) = 1$
        \end{enumerate}
        \item \textbf{$s=$Swamp:}
        \begin{enumerate}
             \item $\text{hur}(\text{Swamp}) - \text{hur}(\text{Mountain}) = 1 - 1 = 0 \leq \text{cst}(\text{Swamp}, \cdot, \text{Mountain}) = 3$
            \item $\text{hur}(\text{Swamp}) - \text{hur}(\text{Plains}) = 1 - 0 = 1 \leq \text{cst}(\text{Swamp}, \cdot, \text{Plains}) = 2$
        \end{enumerate}
        \item \textbf{$s=$Mountain:} 
        \begin{enumerate}
            \item $\text{hur}(\text{Mountain}) - \text{hur}(\text{Jungle}) = 1 - 3 = -2 \leq \text{cst}(\text{Mountain}, \cdot, \text{Desert}) = 6$
            \item $\text{hur}(\text{Mountain}) - \text{hur}(\text{Plains}) = 1 - 0 = 1 \leq \text{cst}(\text{Mountain}, \cdot, \text{Plains}) = 1$
        \end{enumerate}
        \item Therefore, it is consistent.
    \end{enumerate}
\end{example}
\newpage

\begin{process} \textbf{How to Design Heuristic via Problem Relaxation?}
    \begin{enumerate}
        \item Make an assumption to simplify the problem as a relaxed problem. 
        \item Find the cost of the optimal solution of the relaxed problem, $\text{cst}_{\text{rel}}(s)$ from every state $s$ to the goal state.
    \end{enumerate}
\end{process}

\begin{example}
    \customFigure[0.5]{../Images/L2_11.png}{}
\end{example}








